"""
Phase 1: Improved Data Collector
Enhancements based on our first test run
"""

import ccxt
import pandas as pd
import time
import os
from dotenv import load_dotenv
from datetime import datetime

load_dotenv()

def initialize_exchange():
    """Initialize Kraken exchange with better configuration"""
    exchange = ccxt.kraken({
        'apiKey': os.getenv('KRAKEN_API_KEY', ''),
        'secret': os.getenv('KRAKEN_SECRET', ''),
        'enableRateLimit': True,
        'timeout': 30000,
    })
    
    # Test the connection
    try:
        exchange.load_markets()
        print("✓ Kraken exchange initialized and connected")
        return exchange
    except Exception as e:
        print(f"✗ Exchange connection failed: {e}")
        return None

def get_test_pairs():
    # Expand to 3 pairs for better testing
    return ['BTC/USD', 'ETH/USD', 'ADA/USD'] 

def fetch_ohlcv_safe(exchange, symbol, timeframe='1h', limit=100):
    """Improved data fetching with better error handling"""
    try:
        print(f"Fetching {symbol} {timeframe} data...")
        
        ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
        
        if not ohlcv:
            print(f"✗ No data returned for {symbol}")
            return None
            
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df.set_index('timestamp', inplace=True)
        df['symbol'] = symbol
        
        # Fix: Proper volume label
        base_currency = symbol.split('/')[0]
        df.rename(columns={'volume': f'volume_{base_currency}'}, inplace=True)
        
        print(f"✓ Retrieved {len(df)} candles for {symbol}")
        return df
        
    except Exception as e:
        print(f"✗ Error fetching {symbol}: {str(e)}")
        return None

def validate_data(df, symbol):
    """Basic data validation checks"""
    if df is None or df.empty:
        return False
        
    checks = {
        'has_data': len(df) > 0,
        'no_nulls': not df[['open', 'high', 'low', 'close']].isnull().any().any(),
        'positive_prices': (df['close'] > 0).all(),
        'time_gaps': df.index.to_series().diff().max().total_seconds() <= 7200,  # Max 2hr gap
    }
    
    if all(checks.values()):
        return True
    else:
        print(f"  Data issues: {[k for k,v in checks.items() if not v]}")
        return False

def save_data(all_data):
    """Save data to CSV files for later use"""
    os.makedirs('data', exist_ok=True)
    
    for symbol, df in all_data.items():
        filename = f"data/{symbol.replace('/', '_')}.csv"
        df.to_csv(filename)
        print(f"  Saved to {filename}")
    
    print("✓ All data saved to 'data/' directory")

def main():
    print("=== Crypto Pairs Data Collector v2 ===\n")
    
    # Initialize exchange
    exchange = initialize_exchange()
    if exchange is None:
        return
    
    # Get test pairs
    pairs = get_test_pairs()
    print(f"Testing with pairs: {pairs}\n")
    
    # Fetch data
    all_data = {}
    successful_pairs = []
    
    for pair in pairs:
        data = fetch_ohlcv_safe(exchange, pair)
        
        if data is not None and validate_data(data, pair):
            all_data[pair] = data
            successful_pairs.append(pair)
        else:
            print(f"✗ Validation failed for {pair}")
            
        time.sleep(1)  # Rate limiting
    
    # Results summary
    print(f"\n=== Results Summary ===")
    print(f"Successful: {len(successful_pairs)}/{len(pairs)} pairs")
    
    for pair in successful_pairs:
        df = all_data[pair]
        base_currency = pair.split('/')[0]
        volume_col = f'volume_{base_currency}'
        
        print(f"\n{pair}:")
        print(f"  Period: {df.index.min()} to {df.index.max()}")
        print(f"  Records: {len(df)}")
        print(f"  Price: ${df['close'].iloc[-1]:.2f} (range: ${df['close'].min():.2f}-${df['close'].max():.2f})")
        print(f"  Volume: {df[volume_col].mean():.2f} {base_currency}/hour")
    
    # Save data
    if all_data:
        print(f"\n=== Saving Data ===")
        save_data(all_data)
    
    return all_data

if __name__ == "__main__":
    data = main()