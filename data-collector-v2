import ccxt
import pandas as pd
import time
import os
from datetime import datetime, timedelta
from dotenv import load_dotenv

load_dotenv()

def initialize_exchange():
    """Initialize Kraken exchange connection"""
    try:
        exchange = ccxt.kraken({
            'apiKey': os.getenv('KRAKEN_API_KEY', ''),
            'secret': os.getenv('KRAKEN_SECRET', ''),
            'enableRateLimit': True,
            'timeout': 30000,
        })
        
        # Test connection by loading markets
        exchange.load_markets()
        print("‚úì Kraken exchange initialized successfully")
        return exchange
        
    except Exception as e:
        print(f"‚úó Failed to initialize exchange: {e}")
        return None

def get_trading_pairs():
    """Get the pairs we want to track"""
    return ['BTC/USD', 'ETH/USD', 'ADA/USD', 'DOT/USD', 'LINK/USD']

def fetch_historical_data(exchange, symbol, days=180, timeframe='1h'):
    """Fetch historical OHLCV data for a symbol"""
    try:
        print(f"üìä Fetching {days} days of {timeframe} data for {symbol}...")
        
        # Calculate start time
        since = exchange.parse8601((datetime.now() - timedelta(days=days)).isoformat())
        
        all_ohlcv = []
        current_since = since
        
        while True:
            # Fetch data in chunks
            ohlcv = exchange.fetch_ohlcv(symbol, timeframe, since=current_since, limit=720)
            
            if not ohlcv or len(ohlcv) == 0:
                break
                
            all_ohlcv.extend(ohlcv)
            
            # Update cursor for next request
            current_since = ohlcv[-1][0] + 1  # Next millisecond after last candle
            
            # Check if we've reached current time or empty response
            if len(ohlcv) < 720 or current_since > exchange.milliseconds():
                break
                
            # Rate limiting
            time.sleep(0.5)
        
        if not all_ohlcv:
            print(f"‚úó No data received for {symbol}")
            return None
            
        # Create DataFrame
        df = pd.DataFrame(all_ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df.set_index('timestamp', inplace=True)
        df['symbol'] = symbol
        
        print(f"‚úì {symbol}: {len(df)} candles from {df.index.min()} to {df.index.max()}")
        return df
        
    except Exception as e:
        print(f"‚úó Error fetching {symbol}: {e}")
        return None

def validate_data(df, symbol):
    """Validate the quality of fetched data"""
    if df is None or df.empty:
        return False
        
    checks = {
        'min_records': len(df) > 100,
        'no_nulls': not df[['open', 'high', 'low', 'close']].isnull().any().any(),
        'positive_prices': (df['close'] > 0).all(),
        'chronological_order': df.index.is_monotonic_increasing,
    }
    
    failed_checks = [check for check, passed in checks.items() if not passed]
    
    if failed_checks:
        print(f"  ‚ö†Ô∏è  Validation failed for {symbol}: {failed_checks}")
        return False
        
    print(f"  ‚úÖ Data validation passed for {symbol}")
    return True

def save_data(df, symbol, data_dir='data'):
    """Save DataFrame to CSV file"""
    os.makedirs(data_dir, exist_ok=True)
    
    filename = f"{symbol.replace('/', '_')}.csv"
    filepath = os.path.join(data_dir, filename)
    
    df.to_csv(filepath)
    print(f"  üíæ Saved {len(df)} records to {filepath}")

def main():
    print("=" * 50)
    print("CRYPTO PAIRS DATA COLLECTOR v2")
    print("=" * 50)
    
    # Initialize exchange
    exchange = initialize_exchange()
    if not exchange:
        return
    
    # Get trading pairs
    pairs = get_trading_pairs()
    print(f"\nüéØ Tracking {len(pairs)} pairs: {', '.join(pairs)}")
    
    # Fetch data for each pair
    successful_pairs = []
    
    for pair in pairs:
        print(f"\n{'='*30}")
        print(f"Processing {pair}")
        print(f"{'='*30}")
        
        # Fetch historical data (180 days = ~6 months)
        df = fetch_historical_data(exchange, pair, days=180, timeframe='1h')
        
        # Validate data
        if validate_data(df, pair):
            # Save to file
            save_data(df, pair)
            successful_pairs.append(pair)
            
            # Show basic stats
            print(f"  üìà Price: ${df['close'].iloc[-1]:.2f}")
            print(f"  üìä Volume: {df['volume'].mean():.2f} {pair.split('/')[0]}/hour")
        else:
            print(f"  ‚ùå Skipping {pair} due to validation issues")
        
        # Rate limiting between pairs
        time.sleep(1)
    
    # Summary
    print(f"\n{'='*50}")
    print("COLLECTION SUMMARY")
    print(f"{'='*50}")
    print(f"‚úÖ Successful: {len(successful_pairs)}/{len(pairs)} pairs")
    print(f"üìÅ Data saved to: data/ directory")
    
    if successful_pairs:
        print(f"üéØ Pairs collected: {', '.join(successful_pairs)}")
    else:
        print("‚ùå No data was successfully collected")
    
    return successful_pairs

if __name__ == "__main__":
    main()